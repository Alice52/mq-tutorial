## 1. 项目中使用 mq 的场景: 解耦异步削峰

1. 我们的标准产品在于澳大利亚的客户做定制化开发集成时, 核心业务是博彩[记录客人在桌子上的每一笔下注, 及 winloss 的情况], 需要两个系统之间进行消息事件的交换与同步, 比如桌子的创建初始化[ao], 开桌子, 开始做一局局的赌博, 关闭桌子, 销毁桌子; 最终形成 report
2. 为什么不使用 http 交互方式[时间成本]: 因为是非核心业务, 应该解耦出核心业务[下游业务的成功与失败不应该影响此次业务的完成, 服务独立性(服务不可用)数据都有可以运维恢复], 降低系统的复杂度; 而且使用`异步发送+callback`缩短了时间[后面的业务逻辑很复杂]; http 调用的话如果失败了, 重试机制也不太好做[mq 可以解决问题]
3. 定义好双方的交互 schema, 可以双边共同开发, 缩短开发周期
4. 方便测试测试, 我们可以各自模拟 similator 进行测试
5. 使用时带来了系统的复杂度[重复+丢失+顺序], 可用性降低, 一致性问题, 时间消耗

## 2.为什么使用 rabbitmq

1. 我们选用的是 rabbiqmq, 具体的原因是: `轻量快捷`, 社区活跃, 性能稳定比较好, 延时低[微妙级别], 有相关的基本功能[顺序消息/重试机制], 有管理页面

2. 对比表

| diamension |      rabbitmq       | rocketmq  |  activemq  |   kafka    |
| :--------: | :-----------------: | :-------: | :--------: | :--------: |
|    语言    |       erlang        |   java    |    java    |   scala    |
| 单机吞吐量 |          w          |    10w    |     w      |    10w     |
|    时效    |         us          |    ms     |     ms     |     ms     |
|   可以性   |      高[主从]       | 高[主从]  | 高[分布式] | 高[分布式] |
|    社区    |          Y          |     Y     |     N      |     Y      |
|    模型    |      队列模型       | 发-订模型 |     --     | 发-订模型  |
|   other    | 性能稳定好, 并发高, |   二开    |     --     |   大数据   |

## 3.mq 丢消息

1. 事务事务消息但是效率太低: 使 channel 变成事务的, 包含 publish, commit, 吞吐量会下降 250 倍

---

1. 生产者[confirmcallback+return callback]
   - 同步发送: 没有丢消息的情况
   - 异步发送:
     1. 如果没有 callback 会出现消息丢失的情况, 降低核心业务的时间, 失败也不影响核心业务的流程
     2. 有 callback 会但是网络问题也可能丢失消息: callback 内 retry 机制, 如果还失败了就记录 log, 之后发现问题[运维团队]进行数据修复
2. 消费者
   - 幂等性:
   - 手动 ack
3. mq 宕机
   - 消息的投递默认[delivery-mode]选项设置为持久化
   - 发送到持久化的交换机
   - 到达持久化的队列

---

1. 生产者:

   - confirmcallback: `publisher --> broker[exchange] 的确认机制`

     1. 设置: `spring.rabbitmq.publisher-confirms=true` || 创建 connectionfactory 时设置 publisher
     2. correlationData 标识消息的唯一性
     3. 消息需要被 broker 接受之后才会执行 confirmcallback 的逻辑, 如果是集群需要所有的 broker 都接受到才会执行

   - returncallback: `broker[exchange] --> queue`
     1. 消息被没有成功投递到 queue 才会调用 returncallback: queue 不存在 routingkey 不对

2. 消费者需要手动 ack 签收消息

   - 默认从 channel 中获取消息[多条 prefetch_count], 如果消费到一半服务器宕机或者出现异常则会导致未被消费的消息丢失
   - 方法: 手动 ack 签收消息
     1. basic.ack: 签收, 成功消费后对 broker 内的消息进行删除
     2. basic.nack: 拒绝签收消息, 可以设置是否 re-queue, 可以设置批量操作
     3. basic.reject: 同上, 只是不能批量
     4. 拒绝签收之后会再次进入 ready 状态以备消费: `这里有顺序消费的问题+retry 问题`

3. mq

## 10.持久化

1. RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是, 将它们写入磁盘上的一个持久化日志文件
2. 当发布一个持久性消息到持久交换机上时, **Rabbit 会在消息提交到日志文件后才发送响应**
   - 之后这条消息如果路由到了非持久队列的话, 它会自动从持久性日志中移除, 并且无法从服务器重启中恢复
   - 如果你使用持久性消息的话, 则确保之前提到的持久性消息的那三点都必须做到位
3. 一旦你从持久性队列中消费了一个持久性消息的话[并且确认了它], RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集
4. 在你消费持久性消息前, 如果 RabbitMQ 重启的话, 服务器**会自动重建交换机和队列[以及绑定]**, 重**播持久性日志文件的消息到合适的队列或者交换机上**[取决于 Rabbit 服务器宕机的时候, 消息处在路由过程的哪个环节]
5. 虽然持久化消息可以做到消息的不丢失, 但持久化的消息在进入队列前会被写到磁盘, 这个过程比写到内存慢得多, 所以会严重的影响性能, 可能导致消息的吞吐量降低 10 倍不止。所以, 在做消息持久化前, 一定要认真考虑性能和需求之间的平衡关系

## 4.介绍一下 rabbitmq

![avatar](/static/image/mq/rabbitmq.png)

1. broker
2. exchange: 4
3. queue
4. bindingkey/routingkey
5. ack
6. ttl
7. dl

## 5.顺序消费怎么实现的[我们的使用场景是 1:1:1]

1. 全局顺序: 生产者 : mq-server : 消费者= 1:1:1
2. 集群的话
   - 发送: 发送消息时保证一组有顺序的消息放入同一个 queue[但是由于网络原因可能导致消息到达的顺序错乱啊???]
   - 消费: 分段锁, 只能是一个 consumer 消费结束[ack]之后才能被取消息

## 6.保证消息不被重复消费[我们的使用场景是 1:1:1]: 手动 ack 放在 transaction 内

1. ~~生产者发送由于网络原因[无 ack]会重新发送: 可以落库 uid~~
2. 启动多个消费者每个消息只能被一个消费者消费, 所以只要保证一个消费的不重复即可
3. 消费者网络原因无 ack 会再次消费:[rabbitmq 有一个 re-deliver 判断是否第一次传过来]
   - 消费落库 uid+consumerflag[第三方的数据记录下来了类似 log], Id 存在则直接 ack
   - 否则消费: flag 默认是 true, 消费失败是会改为 false

---

### 1:1:1 的重复消费问题

1. 生产者: 带上 `setCorrelationId`: 原理是什么 + 由于网络的原因导致的 mq punlisher 自己的 retry 则带有的 correlationId 是一样的[在可以在消费端解决重复问题]
2. 消费者: 根据上面的 correlationId 做数据落库工作[由于消费成功(修改数据库了), 但是没来得及 ack 导致的消费者认为该消息没有消费]
   - 获取消息的 correlationId 之后查询数据库, 有改数据则直接 ack
   - 没有则开一个 transaction: ack + insert
3. 全量制的更新: 对方给我们系统最新的全量的数据, 我们对自己系统中的数据进行更新, 但是要保证顺序消费[uid+action+不同的消息进入不同的 queue]

## 6.消费者一直失败, 导致消息积压怎么办

1. 产生原因

   - 生产者生产过快 > 消费者速度 :
   - 消费者宕机

2. 解决方法
   - 加消费者数量
   - 先将消息都取出来, 放入数据库或者其他的多个 mq, 是的生产-消费平衡之后再写代码去一点点的 re-publish 或者消费
     1. 重复消费问题
     2. 顺序消费问题

## 7.延时消费

## 8.异步投送

## 9.rabbitmq 高可用

1. 普通集群

![avatar](/static/image/mq/rabbitmq-ha-common.png)

2. 镜像集群

![avatar](/static/image/mq/rabbitmq-ha-mirror.png)

## 11.谈谈对死信队列的理解

1. 消息进入死信队列的场景
   - 队列消息达到 长度
   - 消费者拒绝 ack 且不 re-queue
   - 原 queue 存在消息过期设置, 过期未消费

## 12.了解 rocket mq 吗, 介绍一下

## 13.使用 rabbitmq 过程有遇到什么问题吗

1. crash

## 14.消息过期怎么办

1. 消息设置了过期时间, 过期后应该将其转化如死信队列而不是删除
2. 之后可以 re-publish

## reference

1. https://blog.csdn.net/u014748504/article/details/108147081
